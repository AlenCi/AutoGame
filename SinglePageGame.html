<html>

<head>
    <base href="https://websim.ai">
    <title>AutoBattler Arena</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-container {
            background-color: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #00ff9d;
        }

        .battle-arena {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .character {
            text-align: center;
            background-color: #0f3460;
            border-radius: 5px;
            padding: 10px;
            width: 45%;
        }

        .character-sprite {
            width: 100px;
            height: 100px;
            margin: 0 auto;
            background-color: #533483;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            color: #e94560;
        }

        .health-bar {
            background-color: #4a4e69;
            height: 20px;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }

        .health-fill {
            background-color: #00ff9d;
            height: 100%;
            width: 100%;
            transition: width 0.3s ease-in-out;
        }

        .action-log {
            background-color: #0f3460;
            border-radius: 5px;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            justify-content: center;
        }

        button {
            background-color: #e94560;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #533483;
        }

        button:disabled {
            background-color: #4a4e69;
            cursor: not-allowed;
        }

        .circles {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }

        .circle {
            width: 150px;
            height: 150px;
        }

        .circle-label {
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }

        .log-entry {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .log-text {
            flex-grow: 1;
        }

        .log-pie-chart {
            position: relative;
            width: 50px;
            height: 50px;
            margin-right: 10px;
        }

        @keyframes spin {
            from {
                transform: translateX(-50%) rotate(0deg);
            }

            to {
                transform: translateX(-50%) rotate(var(--final-rotation));
            }
        }


        .log-arrow {
            position: absolute;
            top: 0;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 15px solid rgb(0, 255, 17);
            transform-origin: 50% 25px;
            /* Move origin to bottom center of the arrow */
            animation: spin 2s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
        }

        @keyframes fadeout {
            to {
                opacity: 0;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

</head>

<body>
    <div id="game-container">
        <h1>AutoBattler Arena</h1>
        <div class="battle-arena">
            <div class="character" id="player">
                <div class="character-sprite">ðŸ¦¹</div>
                <h2>Player</h2>
                <div class="health-bar">
                    <div class="health-fill"></div>
                </div>
                <p>HP: <span class="hp">100</span></p>
                <div class="circles">
                    <div>
                        <canvas class="circle" id="player-main-circle"></canvas>
                        <div class="circle-label">Main Circle</div>
                    </div>
                    <div>
                        <canvas class="circle" id="player-special-circle"></canvas>
                        <div class="circle-label">Special Circle</div>
                    </div>
                </div>
            </div>
            <div class="character" id="enemy">
                <div class="character-sprite">ðŸ‘º</div>
                <h2>Enemy</h2>
                <div class="health-bar">
                    <div class="health-fill"></div>
                </div>
                <p>HP: <span class="hp">100</span></p>
                <div class="circles">
                    <div>
                        <canvas class="circle" id="enemy-main-circle"></canvas>
                        <div class="circle-label">Main Circle</div>
                    </div>
                    <div>
                        <canvas class="circle" id="enemy-special-circle"></canvas>
                        <div class="circle-label">Special Circle</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="action-log" id="action-log"></div>
        <div class="controls">
            <button id="start-btn">Start Battle</button>
        </div>
    </div>

    <script>
        class Character {
            constructor(name, emoji, hp) {
                this.name = name;
                this.emoji = emoji;
                this.maxHp = hp;
                this.hp = hp;
                this.mainCircle = [
                    { name: 'Basic Attack', weight: 3, power: 10, color: '#ff6b6b' },
                    { name: 'Special Move', weight: 2, power: 15, color: '#48dbfb' },
                    { name: 'Ultimate', weight: 1, power: 25, color: '#ff9ff3' }
                ];
                this.specialCircle = [
                    { name: 'No Effect', weight: 8, power: 0, color: '#ff6b6b' },
                    { name: 'Dodge', weight: 1, power: 0, color: '#48dbfb' },
                    { name: 'Counter', weight: 1, power: 0.5, color: '#ff9ff3' }
                ];
                this.mainBag = this.createBag(this.mainCircle);
                this.specialBag = this.createBag(this.specialCircle);
            }

            createBag(circle) {
                return circle.flatMap(action => Array(action.weight).fill(action));
            }

            takeTurn() {
                if (this.mainBag.length === 0) {
                    this.mainBag = this.createBag(this.mainCircle);
                }
                const index = Math.floor(Math.random() * this.mainBag.length);
                const action = this.mainBag[index];
                this.mainBag.splice(index, 1);
                return { action, bagBefore: [...this.mainBag, action] };
            }

            defendAttack() {
                if (this.specialBag.length === 0) {
                    this.specialBag = this.createBag(this.specialCircle);
                }
                const index = Math.floor(Math.random() * this.specialBag.length);
                const action = this.specialBag[index];
                this.specialBag.splice(index, 1);
                return { action, bagBefore: [...this.specialBag, action] };
            }

            takeDamage(amount) {
                this.hp = Math.max(0, this.hp - amount);
                return this.hp <= 0;
            }
        }

        class Game {
            constructor() {
                this.player = new Character('Player', 'ðŸ¦¹', 100);
                this.enemy = new Character('Enemy', 'ðŸ‘º', 100);
                this.turn = 0;
                this.gameOver = false;

                this.startBtn = document.getElementById('start-btn');
                this.actionLog = document.getElementById('action-log');

                this.startBtn.addEventListener('click', () => this.startBattle());

                this.updateUI();
                this.drawCircles();
            }
            startBattle() {
                this.startBtn.disabled = true;
                this.fight(); // Start the first fight immediately
                this.battleInterval = setInterval(() => this.fight(), 4000); // Adjust timing as needed
            }

            updateHealthBars() {
                this.updateCharacterUI(this.player);
                this.updateCharacterUI(this.enemy);
            }

            fight() {
                if (this.gameOver) {
                    clearInterval(this.battleInterval);
                    return;
                }

                this.turn++;
                this.log(`--- Turn ${this.turn} ---`);

                let attacker = this.turn % 2 === 1 ? this.player : this.enemy;
                let defender = this.turn % 2 === 1 ? this.enemy : this.player;

                let { action: attack, bagBefore: attackBagBefore } = attacker.takeTurn();
                let { action: defense, bagBefore: defenseBagBefore } = defender.defendAttack();

                const logActions = () => {
                    const attackPieChart = this.createPieChart(attacker.mainCircle, attack, attackBagBefore);
                    const defensePieChart = this.createPieChart(defender.specialCircle, defense, defenseBagBefore);

                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.appendChild(attackPieChart);
                    logEntry.appendChild(defensePieChart);

                    this.actionLog.appendChild(logEntry);
                    this.actionLog.scrollTop = this.actionLog.scrollHeight;

                    setTimeout(() => {
                        const textDiv = document.createElement('div');
                        textDiv.className = 'log-text';
                        textDiv.innerHTML = `${attacker.name} uses ${attack.name}!<br>${defender.name}'s reaction: ${defense.name}`;
                        logEntry.appendChild(textDiv);

                        let damage = attack.power;
                        if (defense.name === 'Dodge') {
                            this.log(`${defender.name} dodges the attack!`);
                        } else if (defense.name === 'Counter') {
                            let counterDamage = Math.floor(damage * 0.5); // 50% damage reflection
                            let defenderDefeated = defender.takeDamage(damage);
                            let attackerDefeated = attacker.takeDamage(counterDamage);

                            this.log(`${defender.name} takes ${damage} damage but counters and deals ${counterDamage} damage back!`);
                            this.log(`${attacker.name} takes ${counterDamage} damage from the counter!`);

                            if (defenderDefeated) {
                                this.gameOver = true;
                                this.log(`${defender.name} has been defeated! ${attacker.name} wins!`);
                                clearInterval(this.battleInterval);
                            } else if (attackerDefeated) {
                                this.gameOver = true;
                                this.log(`${attacker.name} has been defeated by the counter! ${defender.name} wins!`);
                                clearInterval(this.battleInterval);
                            }
                        } else {
                            let defeated = defender.takeDamage(damage);
                            this.log(`${defender.name} takes ${damage} damage!`);

                            if (defeated) {
                                this.gameOver = true;
                                this.log(`${defender.name} has been defeated! ${attacker.name} wins!`);
                                clearInterval(this.battleInterval);
                            }
                        }

                        this.updateHealthBars();
                    }, 2100);
                };

                logActions();
            }

            log(message, pieChartContainer = null) {
                let logEntry = document.createElement('div');
                logEntry.className = 'log-entry';

                if (pieChartContainer) {
                    logEntry.appendChild(pieChartContainer);

                    // Delay the text display
                    setTimeout(() => {
                        let textDiv = document.createElement('div');
                        textDiv.className = 'log-text';
                        textDiv.textContent = message;
                        logEntry.appendChild(textDiv);

                        this.actionLog.scrollTop = this.actionLog.scrollHeight;
                    }, 2100); // Wait for animation to complete (2s) plus a small delay
                } else {
                    let textDiv = document.createElement('div');
                    textDiv.className = 'log-text';
                    textDiv.textContent = message;
                    logEntry.appendChild(textDiv);
                }

                this.actionLog.appendChild(logEntry);
                this.actionLog.scrollTop = this.actionLog.scrollHeight;
            }

            updateUI() {
                this.drawCircles();
            }

            updateCharacterUI(character) {
                let charElement = document.getElementById(character.name.toLowerCase());
                charElement.querySelector('.hp').textContent = character.hp;
                let healthPercent = (character.hp / character.maxHp) * 100;
                charElement.querySelector('.health-fill').style.width = `${healthPercent}%`;
            }

            drawCircles() {
                this.drawPieChart('player-main-circle', this.player.mainCircle, this.player.mainBag);
                this.drawPieChart('player-special-circle', this.player.specialCircle, this.player.specialBag);
                this.drawPieChart('enemy-main-circle', this.enemy.mainCircle, this.enemy.mainBag);
                this.drawPieChart('enemy-special-circle', this.enemy.specialCircle, this.enemy.specialBag);
            }

            drawPieChart(elementId, circleData, bag) {
                const ctx = document.getElementById(elementId).getContext('2d');
                const remainingActions = bag.reduce((acc, action) => {
                    acc[action.name] = (acc[action.name] || 0) + 1;
                    return acc;
                }, {});

                new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: circleData.map(action => action.name),
                        datasets: [{
                            data: circleData.map(action => remainingActions[action.name] || 0),
                            backgroundColor: circleData.map(action => action.color),
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        let action = circleData[context.dataIndex];
                                        label += `${remainingActions[action.name] || 0} remaining, Power ${action.power}`;
                                        return label;
                                    }
                                },
                                bodyFont: {
                                    size: 14
                                },
                                padding: 10,
                                boxWidth: 0,
                                boxHeight: 0,
                                boxPadding: 3,
                                usePointStyle: true,
                                callbacks: {
                                    title: function (tooltipItems) {
                                        return tooltipItems[0].label;
                                    },
                                    label: function (context) {
                                        let action = circleData[context.dataIndex];
                                        return [
                                            `Remaining: ${remainingActions[action.name] || 0}`,
                                            `Power: ${action.power}`
                                        ];
                                    }
                                }
                            }
                        }
                    }
                });
            }

            createPieChart(circleData, hitAction, bagBefore) {
                let container = document.createElement('div');
                container.className = 'log-pie-chart';

                let canvas = document.createElement('canvas');
                canvas.width = 50;
                canvas.height = 50;

                const remainingActions = bagBefore.reduce((acc, action) => {
                    acc[action.name] = (acc[action.name] || 0) + 1;
                    return acc;
                }, {});

                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: circleData.map(action => action.name),
                        datasets: [{
                            data: circleData.map(action => remainingActions[action.name] || 0),
                            backgroundColor: circleData.map(action => action === hitAction ? '#feca57' : action.color),
                        }]
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                });

                container.appendChild(canvas);

                // Add spinning arrow
                let arrow = document.createElement('div');
                arrow.className = 'log-arrow';
                container.appendChild(arrow);

                // Calculate the rotation for the arrow
                const hitIndex = circleData.findIndex(action => action === hitAction);
                const totalWeight = circleData.reduce((sum, action) => sum + action.weight, 0);
                const cumulativeWeights = circleData.reduce((acc, action, index) => {
                    acc[index] = (acc[index - 1] || 0) + action.weight;
                    return acc;
                }, {});

                const hitStart = (cumulativeWeights[hitIndex - 1] || 0) / totalWeight;
                const hitEnd = cumulativeWeights[hitIndex] / totalWeight;
                const randomPoint = hitStart + Math.random() * (hitEnd - hitStart);
                const rotationDegrees = randomPoint * 360;

                // Set the final rotation
                arrow.style.setProperty('--final-rotation', `${rotationDegrees}deg`);

                return container;
            }
        }

        new Game();
    </script>
</body>

</html>